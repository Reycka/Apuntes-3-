- Multiprogramación:
	- Mejora la eficiencia del uso de los recursos del sistema. Un proceso usa la CPU mientras que otro hace una operación de E/S 
	- Gráfico:
		- ![[Pasted image 20251024120502.png]] 
- Niveles de Planificación:
	- Tenemos 3 tipos:
		- Largo plazo: Control de admisión de trabajos en el sistema
		- Medio plazo: Mueve los procesos de memoria principal a secundaria
		- Corto plazo: Decide que procesos de los que están listos, se ejecutan a continuación en la CPU
	- Planificadores en el SO
		- El único planificador de los sistemas operativos actuales es el de corto plazo
		- Los de largo plazo se deben de implementar con programas externos
		- Los de medio plazo han sido sustituidos por un mecanism de paginación
- Eventos de planificación:
	- Determina cuando se ejecuta el planificador para evaluar el estado del sistema 
	- Periódicamente:
		- El temporizador hardware genera una interrupción a intervalos regulares
		- La frecuencia define el tick rate 
		- La rutina de tratamiento de interrupción activa el evento de planificación
	- Tickless
		- La interrupción del temporizador se programa a demanda 
		- Ahorras más energía
		- En Linux solo se usa este cuando hay una única tarea
		
	- CUANDO ACTUA???? 
		- **Cambio estado del proceso:**
			- La tarea se ha bloqueado
			- La tarea se ha desbboqueado
		- **Creación o terminación de un proceso**
			- Después del fork o clone
			- Cuando el proceso termina
		- **Cesión voluntaria:**
			- El proceso cede la CPU
			- El proceso cambia su prioridad
			
- Cambio de contexto:
	- Conjunto de acciones que realiza el SO para cambiar el proceso en ejecución
		- **Cambio en memoria virtual:**
			- Se actualizan los registros en memoria
		-  **Cambio del contexto ejecución de la CPU:**
			- Guardar los registros de propósito general
			- Guardar los regiistros específicos
			- Actualizar el puntero de pila a la nueva tarea
			- Cargar los registros de la nueva tarea
			- Continuar con la ejecución de la nueva tarea
			
- OBJETIVO:
	- **Utilización:** Maximizar el tiempo de uso de la CPU
	- **Productividad:** Maximizar el número de procesos terminados por unidad de tiempo
	- **Tiempo de respuesta:** Minimizar el tiempo desde que empieza el proceso hasta que se produce la primera respuesta
	- **TurnAround:** Minimizar el tiempo desde que entra el proceso en el sistema hasta que termina
	- **Tiempo de espera:** Minimizar el tiempo total en la cola de espera:
		- Tiempo de espera = TurnAround - Tiempo CPU - Tiempo E/S
	- **Fariness:** Reparto equitativo de los recursos modulado por prioridad y características de cada proceso
	 
- ![[Pasted image 20251024123705.png]]
- Algoritmo de planificación:
	- Forst Come First Serve (FCFS)
		- Los procesos se planifican según el orden de entrada
		- Las tareas largas pueden bloquear a las cortas
		- Tiene baja productividad y un alto tiempo de respuesta y latencia
		- ![[Pasted image 20251031111730.png]]
			- W tiempo de espera
			- R tiempo de retorno
				- En T0 empieza en 0 y acaba en 20 
			- Productividad de 4 tareas en 20 ms = 1 tarea en 5 ms
	- Shortest Job First (SJF)
		- Se planifican primero los procesos más cortos
		- Favorece tareas interactivas, la **productividad** y el tiempo medio de espera
		- Se debe conocer el perfil de ejecución de las tareas
		- Las tareas largas apenas pillan de la CPU (Si se pasan muchas tareas cortas las largas no se ejecutan)
		- ![[Pasted image 20251031112251.png]]
			- Se van añadiendo a la cola aquellas tareas que consumen menos ms de la CPU (Primero T0- luego T0-T1, luego T2-T0-T1 y finalmente T3-T2-T0-T1)
	- Round Robin (RR) 
		- Combina FCCFS con periodos fijos de tiempo
		- Un proceso se ejecuta hasta que se bloquea, termina o cede CPU. La cola se gestiona como FIFO
		- Asignación equitativa
		- La productividad depende de cuantos procesos de la misma duración hay (voy poco a poco entonces ninguna tarea no llega a terminar rápido, ya que primero pasa 1, luego pasa otra...)
		- ![[Pasted image 20251031112803.png]]
			- Primero T0, a la que entra T1 manda a dormir a T0, luego pasa T2 y manda a dormir a T1...
	- Shortest Remining Time First (SRTF)
		- Combina SJF con periodos fijos de tiempo
		- El siguiente trabajo en hacerse es el que menor tiempo restante para acabar tiene
		- Se necesita conocer el perfil de ejecución de las tareas
		- Las tareas largas siguen con problemas para pillar procesador
		- ![[Pasted image 20251031113153.png]]

- Colas Multinivel con Retroalimentación
	- Combina distintos algoritmos para perfiles diferentes
		- OBJ1 TurnAround: similar a SJF
		- OBJ2 Tiempo de respuesta: similar a RR
	- Estructura:
		- Los trabajos se clasifican en distintas colas de preparados
		- REGLA 1: Los procesos con mayor prioridad se ejecutan primero
		- REGLA 2: Los procesos con la misma prioridad se ejecutan usando RR
		- REGLA 3: Las tareas empiezan siempre en la cola de mayor prioridad
		- REGLA 4: Si una tara consume todo el cuanto se reduce su prioridad (A mayor CPU uses menos prioridad tienes)
		- ![[Pasted image 20251031121842.png]]
	- Problemas:
		- Inanición:
			- Tareas intensivas en CPU con muchas tareas interactivas
			- **Priority Boost** periodicamente aumenta la prioridad de todas las tareas
		- Abuso de las reglas de planificación
			- Si una tarea cede la CPU antes de que expire el cuanto no baja de prioridad
			- **Accounting CPU** si el tiempo de ejecución total en la cola Q es mayor que el cuanto se reduce la prioridad
		- Las tareas no aumentan la prioridad:
			- Una tara intensiva en CPU seguirá en la mínima prioridad aunque pase a una fase interactiva
			- Priority boost
		- ![[Pasted image 20251031122337.png]]
		- ![[Pasted image 20251031122348.png]]