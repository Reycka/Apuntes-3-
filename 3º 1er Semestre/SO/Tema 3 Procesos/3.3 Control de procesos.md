- Creación de procesos:
	- **pid_t fork(void);**
	- Devuelve:
		- En el proces **hijo**: 0
		- En el proceso **padre**: PID del proceso hijo
		- -1 en caso de **fallo**, no se crea el proceso hijo y se establece errno
	- El kernel crea una copia del proceso padre (task_struct) nuevo proceso
		- Memoria virtual. Incluido los segmentos de código y datos, y el entorno
		- Contexto de ejecución
		- Tabla de descriptores
		- Manejadores de señales
		- Se copia el puntero a la estructura (tabla de descriptores) NO SE COPIA LA TABLA, dentro de la tabla hay archivos con close_on_exec los cuales no se tienen en cuenta en el puntero
	- Código en C: 
		- ![[Pasted image 20251023111515.png]]
	- Ejecutar el programa:
		- Remplaza la imagen del proceso por una nueva
		- El primer elemento del argv es el nombre del programa y el último es NULL
		- La familia de funciones exec(3) usa execv(2)
		- Si se llama a un .exe dentro del código se ejecuta ese .exe, pero el resto de código de por debajo deja de crearse
		- ls - a - l 
			- ls es el programa y -a -l son los argumentos
			- Dentro de la pila de argumentos tendríamos:
				- -ls --> 0
				- -a --> 1
				- -l --> 2
				- NULL 3
		- ![[Pasted image 20251023112523.png]]

- Terminar un proceso:
	- Puede terminar voluntariamente llamando a  _exit(2)_ o ejecutando return desde main
	- Al recibir una señal
	- FInalcización **Voluntaria:
		- void _exit(int status)_ 
		- status es el estado de salida. que debe ser un número menor que 255
			- Por convenio si es 0 es success y 1 failure
			- No devlover nunca el error number ni -1
			- Accesible en la shell via $? o en el proceso padre vía wait
		- Los descriptores de fichero abiertos por el proceso se cierran
		- El proceso padre recibe la señal SIGCHLD
		- La función exit(3) llama a las funciones registradas con atexit(3) y on_exit(3), vacía y cierra los strams abiertos de stdio(3) elimina los ficheros temporales creados por tmpfile(3) hasta que finalmente se ejecuta _exit(2)_ 
	- Estado Zombi:
		-  Un proceso termina y su padre no sincroniza la finalización
		- Esperar a que in proceso hijo termine:
			- pid_t wait(int* wstatus)
			- pid_t waitpid(pid_t pid, int* wstatus, int options)
			- pid inddica a que proces de hijos esperamos
				- >0 Proceso cuyo PID es pid
				- 0 cualquier porceso hijo del grupo
				- -1 cualquier porceso hijo 
				- <-1 un porceso hijo cuyo PGID es -pid
			- Options s una OR a las siguientes funciones:
				- WNOHANG: retorna sin esperar si no hay hijos que hayan terminado
				- WUNTRACED: retorna si un proceso hijo ha sido detenido
				- WCONTINUED: retorna si un proceso hijo detenido ha sido reanudado
			- wstatus contiene información de estado:
				- WIFEXITED(s) indica si el hijo terminó normalmente con _exit(2). En ese caso, WEXITSTATUS(s) devuelve el estado de salida
				-  WIFSIGNALED(s) indica si el hijo terminó al recibir una señal. En ese caso, WTERMSIG(s) devuelve el número de la señal recibida
				
	-  El proceso init:
		- Es el primer proceso que arranca el kernel después de inicializar el sistema
		- Este se encarga de:
			- Gestionar los servicios del sistema
			- subreaper Adopta los procesos huérfanos y ejecuta wait() para recoger los procesos zombie
			
    - Envío de Señales:
	    -  Son interrupciones software, que informan a un proceso de la ocurrencia de un evento de forma asíncrona
	    - Las genera un proceso o el núcleo del sistema
	    - Las opciones son:
		    - Realizar la acción por defecto asocuada a la señal
		    - Capturar la señal con una función manejador
		    - Bloquear la señal
		    - Ignorar la señal
		- Algunas señales:
			- ![[Pasted image 20251023120725.png]] 

		- Envío de señales a un proceso:
			-  Se usa int kill(pid_t, int señal)
				- pid proceso que le llega a la señal
				- señal la señal en cuestion